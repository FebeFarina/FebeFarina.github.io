[
  {
    "question": " \u00bfQu\u00e9 se entiende por abstracci\u00f3n?",
    "answer": "Es el proceso por la interfaz de un objeto muestra su comportamiento pero no como lo hace.\n\nPor ejemplo cuando llamas a una funci\u00f3n sabiendo que hace algo pero no como lo hace.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 estructura dan los traductores de lenguajes de programaci\u00f3n de alto nivel a la memoria de ejecuci\u00f3n?",
    "answer": "Por lo general, para los lenguajes imperativos, los compiladores generan programas que tendr\u00e1n en tiempo de ejecuci\u00f3n una organizaci\u00f3n de la memoria similar a:\n\u2022 **C\u00f3digo**: zona donde se almacenan las instrucciones del programa ejecutable.\n\u2022 **Memoria est\u00e1tica**: zona para variables globales y constantes almacenadas en memoria.\n\u2022 **Pila** (**Stack**): zona para las variables temporales de las llamadas a los procedimientos.\n\u2022 **Mont\u00f3n** (**Heap**): zona para la gesti\u00f3n din\u00e1mica de la memoria.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es un procedimiento (subprograma)?",
    "answer": "> Una funci\u00f3n.\n> \n\n> Segmento de c\u00f3digo separado del bloque principal y que puede ser invocado en cualquier\nmomento desde este o desde otro procedimiento.\n> \n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es un Registro de Activaci\u00f3n (Stack Frame)?",
    "answer": "> Estructura de datos que usa la pila.\n> \n\n> Cuando un procedimiento es llamado, los datos asociados al mismo son almacenados en tiempo de ejecuci\u00f3n en el \u201cRegistro de Activaci\u00f3n\u201d de tipo LIFO. Estos datos son temporales, y cambian tras cada llamada.\n> \n\n"
  },
  {
    "question": " \u00bfCu\u00e1les son las componentes de un registro de activaci\u00f3n?",
    "answer": "Valores a devolver, zona de control, par\u00e1metros, variables locales y temporales.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 se entiende por programaci\u00f3n procedural?",
    "answer": "> Se basa en estructurar el c\u00f3digo en procedimientos.\n> \n\n> Es un paradigma dentro de la programaci\u00f3n imperativa cuya caracter\u00edstica m\u00e1s importante es la utilizaci\u00f3n de procedimientos. De esta forma, durante la ejecuci\u00f3n del programa se hacen llamadas a estos procedimientos con diferentes datos, para obtener diferentes resultados.\n> \n\n"
  },
  {
    "question": " \u00bfCu\u00e1l es el nombre de la instrucci\u00f3n en la que se basaban los primeros lenguajes de programaci\u00f3n para modificar la secuencia de ejecuci\u00f3n de las instrucciones mediante una transferencia incondicional de su control?",
    "answer": "go to\n\n"
  },
  {
    "question": " \u00bfPor qu\u00e9 se considera perjudicial el uso de sentencias go to? (E. Dijkstra, \u201cLetters to the Editor: Go to Statement Considered Harmful\u201d, Comm. ACM vol. 11, n.3, 147-148, 1968.)",
    "answer": "> Porque no se puede seguir bien el flujo del programa.\n> \n\n> El uso irresponsable de sentencias go to dificultan enormemente el an\u00e1lisis y la verificaci\u00f3n del c\u00f3digo de los programas, especialmente de aquellos que contienen bucles.\n> \n\n"
  },
  {
    "question": " \u00bfQu\u00e9 establece el Teorema Fundamental de la Estructura? (C. B\u00a8ohm, G. Jacopini, \u201cFlow diagrams, Turing Machines and Languages with only Two Formation Rules\u201d, Comm. ACM vol. 9, n. 5, 366-371, 1966.)",
    "answer": "Establece que todo algoritmo dentro del paradigma de la programaci\u00f3n estructurada puede ser\nexpresado mediante solamente tres tipos de estructuras:\n\u2022 Secuencia: ejecuci\u00f3n de una orden tras otra.\n\u2022 Selecci\u00f3n/control: redirecci\u00f3n del flujo de entrada mediante condiciones.\n\u2022 Iteraci\u00f3n: uso de bucles.\nEste teorema demuestra que la instrucci\u00f3n GOTO no es estrictamente necesaria y que para todo programa que la utilice existe otro equivalente que no hace uso de dicha instrucci\u00f3n.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 se entiende por programaci\u00f3n estructurada o modular?",
    "answer": "Se basa en la mejora de la calidad del c\u00f3digo utilizando funciones y quitando c\u00f3digo replicado.\n\n"
  },
  {
    "question": " \u00bfCu\u00e1les son las principales caracter\u00edsticas de la programaci\u00f3n estructurada?",
    "answer": "Se basa en utilizar funciones para no replicar c\u00f3digo y se usan 3 estructuras de control; secuencia, selecci\u00f3n e iteraci\u00f3n.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es Ruby?",
    "answer": "Ruby es un lenguaje de programaci\u00f3n interpretado, reflexivo y orientado a objetos\n\n"
  },
  {
    "question": " \u00bfCu\u00e1l es la principal caracter\u00edstica de Ruby?",
    "answer": "Se trata de un lenguaje interpretado donde todo es un objeto.\n\n"
  },
  {
    "question": " \u00bfCu\u00e1l es el constructor est\u00e1ndar?",
    "answer": "Initialize\n\n"
  },
  {
    "question": " \u00bfC\u00f3mo se define un m\u00e9todo en Ruby?",
    "answer": "Con las palabras clave \u201cdef, seguida del fragmento de c\u00f3digo y el consecuente cierre \u201cend\u201d.\n\n"
  },
  {
    "question": " \u00bfCu\u00e1l es el separador de sentencias en Ruby?",
    "answer": "Ruby utiliza dos separadores por defectos:\n\u2022 Salto de l\u00ednea: por lo cu\u00e1l en el c\u00f3digo, no se observa nada.\n\u2022 Punto y coma (;): utilizado normalmente cuando se utilizan varias instrucciones en la\nmisma l\u00ednea.\n\n"
  },
  {
    "question": " \u00bfC\u00f3mo se especifican comentarios en Ruby?",
    "answer": "- Una l\u00ednea: se utiliza almohadilla (#) al comienzo de la l\u00ednea.\n- M\u00faltiples l\u00edneas: se utilizan \u201c=begin\u201d al inicio del bloque y \u201c=end\u201d al final.\n\n"
  },
  {
    "question": " \u00bfC\u00f3mo se especifican la cadenas literales en Ruby?",
    "answer": "Utilizando comillas simples en vez de dobles. Ejemplo: 'hola\\n' hola\\n.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 se entiende por interpolaci\u00f3n de expresiones? \u00bfCu\u00e1l es su sintaxis? \u00bfCu\u00e1l es su sem\u00e1ntica?",
    "answer": "Se entiende como al proceso de insertar el resultado de una expresi\u00f3n dentro de un string. La\nsintaxis que se utiliza es la de \u201c#{expresi\u00f3n}\u201d.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 indican los siguientes prefijos en la declaraci\u00f3n de una variable?",
    "answer": "$: Variable global\n@: Variables de instancia\n@@: Variable de clase\n\n"
  },
  {
    "question": " \u00bfC\u00f3mo se definen los identificadores en Ruby?",
    "answer": "- Variables locales: comenzar por una letra min\u00fascula o gui\u00f3n bajo.\n- Variables globales: comenzar por el s\u00edmbolo \u201c$\u201d.\n- Variables de instancia: comenzar por el s\u00edmbolo \u201c@\u201d.\n- Variables de clase: comenzar por el s\u00edmbolo \u201c@@\u201d.\n- Variables especiales: comenzar por el s\u00edmbolo \u201c$\u201d.\n- Constantes: comenzar por una letra may\u00fascula.\n- Clases: comenzar por una letra may\u00fascula\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es un array? \u00bfCu\u00e1l es la sintaxis para definirlos en Ruby?",
    "answer": "Estructura de datos en la que se almacenan variables de forma consecutiva. Para definir un array se puede hacer de la siguiente manera:\n\na = Array.new\nb = []\nc = %w{elemento1 elemento2}\n\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es un hash? \u00bfCu\u00e1l es la sintaxis para definirlos en Ruby?",
    "answer": "> Estructura de datos en las que se almacenan datos usando operaciones matem\u00e1ticas para obtener la posici\u00f3n en la que ponerlos.\n> \n\n> Un hash es una colecci\u00f3n de objetos ordenada, que a diferencia de los arrays que se ordenan mediante un \u00edndice, estos utilizan pares identificables por una clave y un valor. Para definir un hash se puede hacer de la siguiente manera:\n> \n\na = Hash.new\nb = {}\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es nil en Ruby?",
    "answer": "Nulo.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es un symbol? \u00bfCu\u00e1l es la sintaxis para definirlos en Ruby?",
    "answer": "Un s\u00edmbolo no es m\u00e1s que un objeto que cuenta con un nombre y una ID interna. Se definen con \u2018:\u2019.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 n\u00fameros son 010, 0x1F, 0b1111?",
    "answer": "- 010: 8 (octal).\n- 0x1F: 31 (hexadecimal).\n- 0b1111: 15 (binario).\n\n"
  },
  {
    "question": " \u00bfEs correcto escribir subguiones en un n\u00famero (por ejemplo: 1_000_000)?",
    "answer": "S\u00ed\n"
  },
  {
    "question": " \u00bfCu\u00e1l es la sintaxis para definir expresiones regulares en Ruby?",
    "answer": "Las expresiones regulares est\u00e1n contenidas en '/ expresi\u00f3n /'. Ejemplo: /a+/.\nLa barra invertida \\ sirve para indicar que el siguiente car\u00e1cter no debe ser tratado como car\u00e1cter especial. Los caracteres especiales son ^, $, ?, ., /, \\,[,],{,},(,),+ y *.\n\u2022 . : Cualquier car\u00e1cter.\n\u2022 []: Especificaci\u00f3n por rango. [a-z]\n\u2022 \\w: Letra o n\u00famero, igual que [a-z] [A-Z] y [0-9]\n\u2022 \\W: Cualquier car\u00e1cter que no sea letra o n\u00famero.\n\u2022 \\s: Car\u00e1cter de espacio. Como \\t\\n\\r\\f.\n\n"
  },
  {
    "question": " \u00bfCu\u00e1l es el operador de emparejamiento (matching) en Ruby?",
    "answer": "Es el operador encargado de comparar una variable con una expresi\u00f3n regular. Se utiliza el\noperador: =~\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es un bloque de c\u00f3digo (Code blocks)? \u00bfCu\u00e1l es la sintaxis para definirlos en Ruby?",
    "answer": "Se trata de una porci\u00f3n de c\u00f3digo encerrada entre par\u00e9ntesis {} o entre do\u2026end.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es rvm - Ruby Version Manager?",
    "answer": "Plataforma software para administrar m\u00faltiples instalaciones Ruby en un mismo dispositivo.\n\n"
  },
  {
    "question": " \u00bfQu\u00e9 es pry?",
    "answer": "Shell interactivo para Ruby."
  }
]