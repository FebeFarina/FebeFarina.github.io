[{"question": " 1. \u00bfQu\u00e9 es una clase?", "answer": "Una clase es una plantilla que permite definir el conjunto de caracter\u00edsticas, funcionalidades y\natributos que va disponer un objeto de datos.\n\n"}, {"question": " 2. \u00bfQu\u00e9 es un objeto?", "answer": "Un objeto no es m\u00e1s que una instancia de una clase que consta de un estado y de un\ncomportamiento, junto con las caracter\u00edsticas que tiene definidas a trav\u00e9s de su clase\n\n"}, {"question": " 3. \u00bfQu\u00e9 es una variable local?", "answer": "Una variable local es aquella variable, que solamente es visible dentro del m\u00e9todo en el que fue\ndeclarada.\n\n"}, {"question": " 4. \u00bfQu\u00e9 es una variable de instancia?", "answer": "Una variable de instancia, son las variables adscritas a un objeto, a las cuales solamente se puede\nacceder mediante el propio objeto.\n\n"}, {"question": " 5. \u00bfQu\u00e9 es una variable global?", "answer": "Una variable global es aquella que se define fuera del cuerpo de cualquier m\u00e9todo, normalmente\nal principio del programa, la cual puede ser accesible desde cualquier parte del programa.\n\n"}, {"question": " 6. \u00bfQu\u00e9 es una variable de clase?", "answer": "Una variable de clase, es aquella variable que es compartida por todas las instancias de la propia\nclase. Si por ejemplo, un objeto cambia el valor de esta variable de clase, ese valor cambia para el\nresto de objetos que intentan acceder a ella.\n\n"}, {"question": " 7. \u00bfQu\u00e9 es un m\u00e9todo de acceso (getter )?", "answer": "Se trata de aquel m\u00e9todo que permite acceder a los datos de las variables de instancia de un objeto (adem\u00e1s de variables de clase).\n\n"}, {"question": " 8. \u00bfQu\u00e9 es un m\u00e9todo de asignaci\u00f3n de valores (setter )?", "answer": "Se trata de aquel m\u00e9todo que permite modificar el valor de las variables de instancia de un\nobjeto (adem\u00e1s de variables de clase).\n\n"}, {"question": " 9. \u00bfCu\u00e1l es la visibilidad del m\u00e9todo initialize?", "answer": "A excepci\u00f3n del resto de m\u00e9todos, que en Ruby por defectos son p\u00fablicos, el m\u00e9todo initialize es\nun m\u00e9todo privado. S\u00f3lo se puede invocar desde el contexto del objeto actual.\n\n"}, {"question": " 10. El valor retornado por initialize es usado para la construcci\u00f3n del objeto. \u00bfVerdadero o falso?", "answer": "Falso, el que crea los datos es la llamada new y el initialize le asigna unos valores.\n"}, {"question": " c) \u00bfattr_accessor es un m\u00e9todo de instancia o de clase?", "answer": "attr_accessor es un m\u00e9todo de instancia del objeto.\n\n"}, {"question": " d) \u00bfEn qu\u00e9 clase est\u00e1 definido attr_accessor?", "answer": "Est\u00e1 definido en la clase Module, la cual es heredada por la clase Class.\n\n"}, {"question": " 14. Considere la creaci\u00f3n de una clase Ruby para representar n\u00fameros fraccionarios. \u00bfC\u00f3mo se denominan a los m\u00e9todos necesarios para definir las siguientes operaciones? \u00bfCu\u00e1ntos argumentos reciben?", "answer": "- La suma, la resta, la multiplicaci\u00f3n, la divisi\u00f3n: +(other), -(other), *(other), /(other)\n- El opuesto: -@\n- La indexaci\u00f3n: []\n- La asignaci\u00f3n a un elemento del objeto: =(other)\n    \n"}, {"question": " 15. \u00bfQu\u00e9 es el polimorfismo?", "answer": "El polimorfismo es la propiedad de una clase para poder ser utilizado con diferentes tipos de\ndatos u objetos, de esta forma las subclases pueden heredar las operaciones pero tiene la\nposibilidad de modificar localmente el comportamiento de estas operaciones.\n\n"}, {"question": " 16. \u00bfCu\u00e1l es la diferencia entre tipo y clase?", "answer": "La clase es aquella con la que se genera el objeto con new, mientras que el tipo es el conjunto de m\u00e9todos o funciones a las que responde un objeto.\n\n"}, {"question": " 17. \u00bfQu\u00e9 ventajas e inconvenientes se tienen si en la escritura de un m\u00e9todo metodo(x,y) se usa respond_to? para comprobar que los argumentos x e y responden a los m\u00e9todos llamados en el cuerpo del m\u00e9todo metodo? ft. ChatGPT", "answer": "Ventajas:\n\n- Asegurar que los argumentos pasados son del tipo correcto y tienen los m\u00e9todos necesarios disponibles para ser utilizado en el m\u00e9todo.\n- Ayudar a evitar errores en tiempo de ejecuci\u00f3n debido a un argumento no v\u00e1lido.\n- Proporciona una mayor flexibilidad en el dise\u00f1o del c\u00f3digo, ya que se pueden aceptar diferentes tipos de objetos como argumentos.\n\nInconvenientes:\n\n- Puede aumentar la complejidad del c\u00f3digo y la cantidad de l\u00edneas necesarias para comprobar los argumentos.\n- Puede hacer que el c\u00f3digo sea m\u00e1s lento debido a la necesidad de comprobar los argumentos antes de ejecutar el cuerpo del m\u00e9todo.\n- Puede ser confuso para otros desarrolladores que lean el c\u00f3digo si no est\u00e1 claramente documentado qu\u00e9 objetos y m\u00e9todos se esperan como argumentos.\n\n"}, {"question": " 18. \u00bfQu\u00e9 ventajas e inconvenientes se tienen si en la escritura de un m\u00e9todo metodo(x,y) se usa is_a? para comprobar que los argumentos x e y pertenecen a las clases esperadas por el m\u00e9todo metodo?", "answer": "La ventaja es que podemos comprobar si un objeto pertenece a cierta clase, o esta contenida\ndentro de varias mediante herencia. El inconveniente que si el objeto responde al m\u00e9todo, pero\nno pertenece a la clase, no pasa, es menos flexible.\n\n"}, {"question": " 19. En Ruby \u00bfel conocimiento de la clase obj.class del objeto obj caracteriza la conducta del objeto?", "answer": "No tiene porqu\u00e9, ya que solamente indica el tipo de objeto que es. Para conocer la conocer la\nconducta del objeto se debe invocar a respond_to?.\n\n"}, {"question": " 20. \u00bfQu\u00e9 clase de objeto crea la llamada Fraction = Struct.new(:num, :denom)?", "answer": "Se trata de un objeto de tipo Class.\n"}, {"question": " 22. \u00bfQu\u00e9 es una variable de clase?", "answer": "Una variable de clase, es aquella variable que es compartida por todas las instancias de la propia\nclase.\n"}, {"question": " 24. \u00bfEs posible definir una constante de la clase MyClass antes de la definici\u00f3n del m\u00e9todo initialize?", "answer": "S\u00ed se puede, ya que una variable de clase no necesita de instancias para existir\n\n"}, {"question": " 25. \u00bfEs posible definir constantes de una clase desde fuera de la misma?", "answer": "S\u00ed, es posible utilizando '::'. Ejemplo: Clase::NUEVA_CONSTANTE = 10\n\n"}, {"question": " 27. \u00bfQu\u00e9 se entiende por herencia?", "answer": "La herencia es un mecanismo de relaci\u00f3n que puede existir entre dos clases, donde una de ellas\n(llamada clase hija/subclase) hereda los atributos y los m\u00e9todos de la otra (llamada clase\nmadre/superclase) cre\u00e1ndose una jerarqu\u00eda de clases.\n\n"}, {"question": " 28. Enumere los tipos de herencia y descr\u00edbalos brevemente.", "answer": "Hay dos tipos de herencia:\n\u2022 Herencia simple: una clase s\u00f3lo puede heredar de otra clase.\n\u2022 Herencia m\u00faltiple: una clase puede heredar de varias clases a la vez.\n\n"}, {"question": " 29. \u00bfQu\u00e9 tipo de herencia proporciona Ruby?", "answer": "Ruby solamente proporciona herencia simple.\n\n"}, {"question": " 30. \u00bfQu\u00e9 se entiende por invalidaci\u00f3n de un m\u00e9todo (overriden)?", "answer": "Se trata de un mecanismo utilizado en la herencia de clases que permite modificar el contenido o\nla funcionalidad de un m\u00e9todo de la superclase. Basta con crear un m\u00e9todo con el mismo nombre\nen la clase hija. De esta forma, si se invoca al m\u00e9todo en vez de invocar al m\u00e9todo de la\nsuperclase, se invoca al m\u00e9todo de la propia clase con las nuevas caracter\u00edsticas.\n\n"}, {"question": " 31. \u00bfQu\u00e9 puede ocurrir si en una subclase se escribe un m\u00e9todo con con nombre intimo igual al de un m\u00e9todo privado intimo de la superclase? \u00bfQu\u00e9 ocurre si el m\u00e9todo toto de la superclase llama a intimo?", "answer": "Pues se sigue produciendo una invalidaci\u00f3n del m\u00e9todo, y en vez de llamarse al m\u00e9todo de la\nsuperclase, se llama al de la subclase. Esto es debido al \u00e1mbito de la ejecuci\u00f3n, aunque el m\u00e9todo\neste en la superclase nuestra instancia es de la subclase. A la hora de invocar un m\u00e9todo primero\nse comprueba su existencia en la propia clase, y posteriormente en los de la superclase.\n\n"}, {"question": " 32. \u00bfQu\u00e9 ocurre cuando se llama a super sin argumentos?", "answer": "Depende de la sintaxis, puede ocurrir una cosa u la otra. Ruby diferencia estas dos sentencias:\n\u2022 **super**: llama al m\u00e9todo de la superclase con el mismo nombre pas\u00e1ndose por defecto\ntodos los argumentos.\n\u2022 **super()**: llama al m\u00e9todo de la superclase sin pasarle ning\u00fan argumento.\n\n"}, {"question": " 33. \u00bfC\u00f3mo se puede llamar a super sin argumentos?", "answer": "Es necesario utilizar par\u00e9ntesis: super().\n"}, {"question": " 35. Suponga que la clase B hereda de A un m\u00e9todo tutu que usa la constante C definida en A. Si en la clase B se define C, \u00bfQu\u00e9 definici\u00f3n de C usar\u00e1 tutu, la de A o la de B?", "answer": "Las constantes se buscan primero en el \u00e1mbito, y posteriormente sube en la jerarqu\u00eda. Se usar\u00e1 la\nde B.\n"}, {"question": " 36. \u00bfQu\u00e9 es la encapsulaci\u00f3n?", "answer": "Es un mecanismo que permite el ocultamiento del estado, es decir, de los datos miembro de un\nobjeto de manera que s\u00f3lo se pueda cambiar mediante las operaciones definidas para ese\nobjeto.\n\n"}, {"question": " 37. \u00bfCu\u00e1l es la visibilidad por defecto de un m\u00e9todo?", "answer": "Por defecto los m\u00e9todos de una clase son p\u00fablicos (a excepci\u00f3n del m\u00e9todo intialize que es\nprivado).\n\n"}, {"question": " 38. \u00bfCu\u00e1l es la visibilidad por defecto de un m\u00e9todo que ha sido definido fuera de cualquier clase (por ejemplo en un script)?", "answer": "Es p\u00fablico/global, puede ser accedido desde cualquier parte del c\u00f3digo\n\n"}, {"question": " 39. Los m\u00e9todos privados no pueden ser llamados desde una subclase, \u00bfcierto o falso?", "answer": "Falso, una subclase s\u00ed puede acceder a los m\u00e9todos privados de la superclase, pero una instancia\nno.\n\n"}, {"question": " 40. Dentro de una clase y fuera de un m\u00e9todo self, \u00bfa qu\u00e9 objeto hace referencia self?", "answer": "A la propia clase.\n\n"}, {"question": " 41. \u00bfC\u00f3mo se denomina la superclase de la clase Class?", "answer": "Se llama Module.\n\n"}, {"question": " 42. La palabra reservada private seguida del nombre de un m\u00e9todo permite restringir el acceso a dicho m\u00e9todo. \u00bfQu\u00e9 es falso en la afirmaci\u00f3n anterior?", "answer": "Private no es una palabra reservada, es un m\u00e9todo.\n\n"}, {"question": " 43. \u00bfQu\u00e9 es un m\u00f3dulo?", "answer": "Un m\u00f3dulo es una colecci\u00f3n de m\u00e9todos, constantes y variables de clase al igual que una clase,\naunque a diferencia de esta, un m\u00f3dulo no puede ser instanciado y no puede ser heredado\n(aunque puede ser incluido).\n\n"}, {"question": " 44. \u00bfQu\u00e9 es un espacio de nombres (namespace)?", "answer": "Un espacio de nombres es un contenedor abstracto en el que un grupo de uno o m\u00e1s\nidentificadores \u00fanicos pueden existir\n\n"}, {"question": " 45. \u00bfQu\u00e9 es un (mix-in)?", "answer": "Un mix-in es una clase que ofrece cierta funcionalidad para ser heredada por una subclase, pero\nno est\u00e1 ideada para ser aut\u00f3noma.\n\n"}, {"question": " 46. \u00bfQu\u00e9 es Enumerable?", "answer": "Es un mix-in que provee de m\u00e9todos para la enumeraci\u00f3n de objetos, siempre y cuando el\nm\u00e9todo each est\u00e9 definido en la clase.\n\n"}, {"question": " 47. \u00bfQu\u00e9 es Comparable?", "answer": "Es un mix-in que provee m\u00e9todos para poder comparar objetos, siempre y cuando el m\u00e9todo <=>\nest\u00e9 definido en la clase.\n\n"}, {"question": " 48. \u00bfQu\u00e9 operador se ha de definir para que a partir de \u00e9l se puedan comparar elementos de la clase?", "answer": "El m\u00e9todo <=>.\n\n"}, {"question": " 49. \u00bfQu\u00e9 m\u00f3dulo se debe incluir para poder ordenar objetos?", "answer": "El m\u00f3dulo Comparable.\n\n"}, {"question": " 50. \u00bfQu\u00e9 diferencias hay entre los siguientes predicados?", "answer": "**a) ==** : definida en Object, se puede invalidar por String, Array, Hash, Numeric.\nComprueban el valor, por lo 1==1 TRUE. \u2192\n**b) eql?**: igual que equal? Pero se puede invalidar. Comprueban el tipo, por lo que 1==1.0 \u2192\nFalse.\n**c) equal?**: definida en Object, no se puede invalidar. Comprueba si el contenido del objeto\nes el mismo. Comprueba si dos objetos son la misma instancia, apuntan a la misma\ndirecci\u00f3n de memoria.\n**d) ===** : equivalente a is_a?. Devuelve TRUE si lo que hay a la derecha de === est\u00e1\ncontenido en la cadena colocada a la izquierda de ===.\n**e) =~** : compara con expresi\u00f3n regular.\n"}, {"question": " 52. \u00bfCu\u00e1l es la diferencia entre obj.nil? y obj == nil?", "answer": "A efectos pr\u00e1cticos es lo mismo, sin embargo Obj.nil? Siempre devolver\u00e1 falso a excepci\u00f3n de\ninvocarlo con el propio nil sin realizar ninguna comprobaci\u00f3n. Lo contrario a \u201cobj == nil\u201d, donde si\nque se realizar\u00e1 esa comprobaci\u00f3n.\n\n"}, {"question": " 53. \u00bfC\u00f3mo se puede permitir que los objetos de la clase Fraction = Struct.new(:num, :denom) sean comparables?", "answer": "Incluyendo el m\u00f3dulo Comparable, y definiendo el metodo <=>.\n\n"}, {"question": " 54. \u00bfQu\u00e9 predicado es usado por Ruby para comprobar la igualdad entre claves de un hash?", "answer": "El m\u00e9todo eql?\n\n"}, {"question": " 55. \u00bfC\u00f3mo se puede conseguir qu\u00e9 el producto de un n\u00famero por un objeto de una clase que se est\u00e1 definiendo funcione? Por ejemplo: 4 * obj", "answer": "Mediante el uso de conversiones. Hay dos tipos de conversiones:\n\u2022 Expl\u00edcitas: utilizaci\u00f3n de m\u00e9todos como to_s o to_i sobre el propio objeto.\n\u2022 Impl\u00edcitas: definiendo un m\u00e9todo llamado coerce.\n\n"}, {"question": " 56. protected es un m\u00e9todo de instancia de la clase Module \u00bfVerdadero o falso?", "answer": "Verdadero.\n\n"}, {"question": " 57. \u00bfDisponen los elementos de la clase Module de un m\u00e9todo new?", "answer": "No, ya que un m\u00f3dulo no puede instanciar objetos.\n\n"}, {"question": " 58. \u00bfQu\u00e9 es una clase abstracta?", "answer": "Una clase abstracta es aquella que no se puede instanciar, est\u00e1 dise\u00f1ada s\u00f3lo como superclase\nde la cual se deben derivar clases hijas.\n\n"}, {"question": " 59. \u00bfC\u00f3mo se define una clase concreta?", "answer": "class derivada << superclase\nend\n\n"}, {"question": " 60. \u00bfC\u00f3mo se denomina la clase a la que pertenecen las clases de Ruby? Dibuje la jerarqu\u00eda de clases a la que pertenece.", "answer": "La clase Class \u2192 Module \u2192 Object \u2192 BasicObjetc.\n"}, {"question": " 63. \u00bfQu\u00e9 es un m\u00e9todo singleton?", "answer": "Un m\u00e9todo singleton es aquel m\u00e9todo que est\u00e1 definido solamente para una \u00fanica instancia.\n\n"}, {"question": " 64. \u00bfCu\u00e1l es la sintaxis Ruby para crear un m\u00e9todo singleton?", "answer": "def objeto.metodo\n\u2026\nend\n"}, {"question": " 66. \u00bfQu\u00e9 es la eigenclass?", "answer": "Se considera eigenclass a la clase an\u00f3nima que contiene los m\u00e9todos singleton definidos de una\ninstancia. La instancia hereda esta clase.\n\n"}, {"question": " 67. Sea x una variable que contiene un objeto de la clase Class. \u00bfCon qu\u00e9 otro nombre se conoce a los m\u00e9todos singleton del objeto x?", "answer": "M\u00e9todos de clase.\n\n"}, {"question": " 68. \u00bfEn qu\u00e9 clase se alojan los m\u00e9todos singleton de x?", "answer": "En la clase singleton, tambi\u00e9n conocida como eigenclass.\n\n"}, {"question": " 69. \u00bfQu\u00e9 diferencia hay entre la eigenclass de un objeto de la clase Class y la de un objeto ordinario?", "answer": "La eigenclas de un objeto de la clase Class puede ser heredada mientras que la de los objetos\nordinarios no.\n"}, {"question": " 71. \u00bfQu\u00e9 ocurre si en una clase C se incluyen dos m\u00f3dulos M1 y M2 (en ese orden) en los que existen m\u00e9todos con el mismo nombre a_method?", "answer": "Si se incluy\u00f3 primero M1 y posteriormente M2, primero se realizar\u00e1 una b\u00fasqueda en M2, y posteriormente si no encuentra el m\u00e9todo solicitado, en M1.\n\n"}, {"question": " 72. \u00bfQu\u00e9 ocurre si en una clase C se incluye un m\u00f3dulo M en el que existe un m\u00e9todo a_method con el mismo nombre que un m\u00e9todo a_method que ya existe en la clase C?", "answer": "Antes de buscar m\u00e9todos en los m\u00f3dulos por orden inverso, primero se busca en la propia clase.\nDe esta forma, se llamar\u00e1 al m\u00e9todo definido en la clase en vez de al m\u00e9todo del m\u00f3dulo.\n\n"}, {"question": " 73. Considere la expresi\u00f3n obj.m donde se llama al m\u00e9todo m con receptor el objeto obj. \u00bfEn qu\u00e9 clase busca Ruby primero a m?", "answer": "La primera vez la b\u00fasqueda se realiza en la eigenclass del propio objeto.\n"}, {"question": " 77. \u00bfQu\u00e9 es un m\u00e9todo singleton de una clase?", "answer": "Un m\u00e9todo singleton de una clase es aquel m\u00e9todo que est\u00e1 definido solamente para una \u00fanica\nclase.\n"}, {"question": " 79. \u00bfQu\u00e9 tipo de \u00e1mbito se utiliza para la b\u00fasqueda de constantes en Ruby?", "answer": "\u00c1mbito est\u00e1tico.\n"}, {"question": " 82. \u00bfQu\u00e9 devuelve? \u00bfPor qu\u00e9?", "answer": "Devuelve nil, ya que no se especific\u00f3 un valor de retorno\n"}, {"question": " 102. \u00bfQu\u00e9 es un conjunto de pruebas (Test case)?", "answer": ""}, {"question": " 103. \u00bfQu\u00e9 es una afirmaci\u00f3n (assertion)?", "answer": ""}, {"question": " \u00bfEn qu\u00e9 consiste la comprobaci\u00f3n continua (Continous Testing)?", "answer": ""}]